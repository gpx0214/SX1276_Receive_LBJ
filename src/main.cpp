/*
   SX1276 LBJ Message Receive Project
   Migrated by FLN1021 on Sep 2023.
   Modified from RadioLib Pager (POCSAG) Receive Example.
   Original file:
   https://github.com/jgromes/RadioLib/blob/master/examples/Pager/Pager_Receive/Pager_Receive.ino
*/
/*
   RadioLib Pager (POCSAG) Receive Example

   This example shows how to receive FSK packets without using
   SX127x packet engine.

   This example receives POCSAG messages using SX1278's
   FSK modem in direct mode.

   Other modules that can be used to receive POCSAG:
    - SX127x/RFM9x
    - RF69
    - SX1231
    - CC1101
    - Si443x/RFM2x

   For default module settings, see the wiki page
   https://github.com/jgromes/RadioLib/wiki/Default-configuration#sx127xrfm9x---lora-modem

   For full API reference, see the GitHub Pages
   https://jgromes.github.io/RadioLib/
*/
#pragma execution_character_set("utf-8")

// include libraries
#include <RadioLib.h>
#include "coredump.h"
#include "BCH.hpp"

// #include <esp_task_wdt.h>
// #include "ScreenWrapper.h"
#include "Menu.h"
// #include "aFFS.h"
#include "aPreferences.h"
// #include "aEFS.h"

#define WDT_TIMEOUT 20 // sec
// #define WDT_RST_PERIOD 4000 // ms
#define FD_TASK_STACK_SIZE 3000 // 5000 // 68200
#define FD_TASK_TIMEOUT 750 // ms
#define FD_TASK_ATTEMPTS 3
#define LED_ON_TIME 200 // ms
//region Variables
// StackType_t statictask_stack[FD_TASK_STACK_SIZE];
// StaticTask_t statictask_tcb;
SX1276 radio = new Module(RADIO_CS_PIN, RADIO_DIO0_PIN, RADIO_RST_PIN, RADIO_DIO1_PIN);
// receiving packets requires connection
// to the module direct output pin
const int pin = RADIO_BUSY_PIN;
float rssi_cache = 0;
// float fer = 0;
float fers[32]{};
float actual_frequency = 0;
float freq_last = 0;
float car_fer_last = 0;
// create Pager client instance using the FSK module
PagerClient pager(&radio);
// timers
uint64_t format_task_timer = 0;
uint64_t runtime_timer = 0;
uint64_t screen_timer = 0;
uint64_t led_timer = 0;
uint64_t timer4 = 0;
uint64_t btn_timer = 0;
// uint64_t wdt_timer = 0;
uint64_t net_timer = 0;
uint64_t prb_timer = 0;
uint64_t car_timer = 0;
uint32_t prb_count = 0;
uint32_t car_count = 0;
uint32_t ip_last = 0;
float ppm = INITIAL_PPM;

inline float actualFreq(float bias) {
    actual_frequency = (float) ((TARGET_FREQ * bias) / 1e6 + TARGET_FREQ);
    return actual_frequency;
}

bool freq_correction = AFC_ENABLE;
// bool bandwidth_altered = false;
bool is_startline = true;
bool exec_init_f80 = false;
// bool agc_triggered = false;
// bool low_volt_warned = false;
bool give_tel_rssi = false;
bool give_tel_gain = false;
bool tel_set_ppm = false;
bool no_wifi = false;
bool have_cd = false;
bool btn_pressed = false;
bool telnet_online = false;
bool first_rx = false;
SD_LOG sd1;
aPreferences flash;
Menu oled;
struct rx_info rxInfo;
struct data_bond *db = new data_bond; // MODIFY
bool always_new = true;
// PagerClient::poc32 &pd = nullptr;

uint32_t start_cnt = 0;
//endregion

//region Functions
void formatDataTask(void *pVoid);

void simpleFormatTask();

void initFmtVars();

void handleSerialInput();

void handleCarrier();

void handlePreamble();

void revertFrequency();

#ifdef HAS_AD_BUTTON

void handleButtonInput();

#endif
TaskHandle_t task_fd;
enum task_states {
    TASK_INIT = 0,
    TASK_CREATED = 1,
    TASK_RUNNING = 2,
    TASK_DONE = 3,
    TASK_TERMINATED = 4,
    TASK_CREATE_FAILED = 5,
    TASK_RUNNING_SCREEN = 6
};

task_states fd_state;

void dualPrintf(bool time_stamp, const char *format, ...) { // Generated by ChatGPT.
    char buffer[256]; // 创建一个足够大的缓冲区来容纳格式化后的字符串
    va_list args;
    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args); // 格式化字符串
    va_end(args);

    // 输出到 Serial
    Serial.print(buffer);

    // 输出到 Telnet
    if (telnet_online) { // code from Multimon-NG unixinput.c 还得是multimon-ng，chatGPT写了四五个版本都没解决。
        if (is_startline) {
            telnet.print("\r> ");
            if (time_stamp && getLocalTime(&time_info, 1))
                telnet.printf("\r%d-%02d-%02d %02d:%02d:%02d > ", time_info.tm_year + 1900, time_info.tm_mon + 1,
                              time_info.tm_mday, time_info.tm_hour, time_info.tm_min, time_info.tm_sec);
            is_startline = false;
        }
        telnet.print(buffer);
        if (nullptr != strchr(buffer, '\n')) {
            is_startline = true;
            telnet.print("\r< ");
        }
    }
}

void dualPrint(const char *fmt) {
    Serial.print(fmt);
    telnet.print(fmt);
}

void dualPrintln(const char *fmt) {
    Serial.println(fmt);
    telnet.println(fmt);
}

// void LBJTEST() {
//     PagerClient::pocsag_data pocdat[16];
//     pocdat[0].str = "37012";
//     pocdat[0].address = 1234000;
//     pocdat[0].function_code = 1;
//     pocdat[0].is_empty = false;
//     pocdat[0].len = 15;
//     pocdat[1].str = "30479100018530U)*9UU*6 (-(202011719040139058291000";
//     pocdat[1].address = 1234002;
//     pocdat[1].function_code = 1;
//     pocdat[1].is_empty = false;
//     pocdat[1].len = 0;
// //    Serial.println("[LBJ] 测试输出 机车编号 位置 XX°XX′XX″ ");
// //    dualPrintf(false,"[LBJ] 测试输出 机车编号 位置 XX°XX′XX″ \n");
//     struct lbj_data lbj;

//     // db = new data_bond;
//     // db->poc32[0].address = 1234000;
//     // db->poc32[0].str = "37012  15  1504";
//     // db->poc32[0].function_code = 1;
//     // db->poc32[0].is_empty = false;
//     // db->poc32[0].len = 15;
//     // db->poc32[1].str = "20202350018530U)*9UU*6 (-(202011719040139058291000";
//     // db->poc32[1].address = 1234002;
//     // db->poc32[1].function_code = 1;
//     // db->poc32[1].is_empty = false;
//     // db->poc32[1].len = 0;
//     readDataLBJ(pocdat, &lbj);
//     printDataSerial(pocdat, lbj, rxInfo);
//     // // appendDataLog(pocdat, lbj, rxInfo);
//     // // printDataTelnet(pocdat, lbj, rxInfo);
//     // simpleFormatTask();
//     // rxInfo.rssi = 0;
//     // rxInfo.fer = 0;
//     // delete db;
// }

void RadioReg() {
    for (uint8_t i=0; i < 0x73; i++) {
        if (i % 16 == 0) {
            Serial.printf("\n[SX1276]reg %02X: ", i);
        }
        uint8_t v = radio.getMod()->SPIreadRegister(i);
        Serial.printf("%02X ", v);
    }
}

int initPager() {// initialize SX1276 with default settings
    bch_err_map_init();

    int state = radio.beginFSK(821.2375, 1.2, 4.5, 12.5);
    RADIOLIB_ASSERT(state)

    state = radio.setGain(1);
    RADIOLIB_ASSERT(state)

    // state = radio.setRxBandwidth(25);
    // RADIOLIB_ASSERT(state)
    // initialize Pager client
    // Serial.print(F("[Pager] Initializing ... "));
    // base (center) frequency: 821.2375 MHz + ppm
    // speed:                   1200 bps
    state = pager.begin(actualFreq(ppm), 1200, false, 2500);
    RADIOLIB_ASSERT(state)

    freq_last = actual_frequency;

    // start receiving POCSAG messages
    // Serial.print(F("[Pager] Starting to listen ... "));
    // address of this "pager": 12340XX
    state = pager.startReceive(pin, 1234000, 0xFFFF0);
    //TODO Enhancement: try to keep a open address filter, we might find something unknown.
    RADIOLIB_ASSERT(state)

    // state = radio.setFrequency(actual_freq);
    // RADIOLIB_ASSERT(state)

    // RadioReg();

    return (state);
}
//endregion

// SETUP
void setup() {
    esp_core_dump_init();
    runtime_timer = millis64();
    esp_reset_reason_t reset_reason = esp_reset_reason();
    initBoard();
    if (u8g2) {
        u8g2->setFont(FONT_12_GB2312);
        u8g2->drawUTF8(80, 8, printResetReason(reset_reason)+8);
        u8g2->updateDisplayArea(10, 0, 6, 1);
    }
    sd1.setFS(SD);
    delay(150);

    // Configure time sync.
    sntp_set_time_sync_notification_cb(timeAvailable);
    sntp_servermode_dhcp(1);
    // configTime(gmtOffset_sec, daylightOffset_sec, ntpServer1, ntpServer2);
    configTzTime(time_zone, ntpServer1, ntpServer2);

    // flash.setIO(SPIFFS, Serial);
    flash.begin("cache", false);
    start_cnt = flash.incStartTime();

    // SPIFFS.format();
    // flash.setIndexPath("/","index.bin");
    // flash.usePath("/", "CACHE", false);
    // flash.listDir("/");

#ifdef HAS_RTC
    // rtc.begin();
    // rtc.getDateTime(time_info);
    if (have_rtc) {
        time_info = rtcLibtoC(rtc.now());
        Serial.print(&time_info, "[eRTC] RTC Time %Y-%m-%d %H:%M:%S ");
        timeSync(time_info); // sync system time from rtc
        Serial.printf("SYS Time %s\n", fmtime(time_info));
        oled.drawTime();
        last_hour = time_info.tm_hour;
    }
#endif

    Serial.printf("cnt %d RST: %s\n", start_cnt, printResetReason(reset_reason));
    if (have_sd) {
        sd1.begin("/LOGTEST");
        sd1.beginCSV("/CSVTEST");
        sd1.append("电池电压 %1.2fV\n", battery.readVoltage() * 2);
        sd1.append(2, "调试等级 %d\n", LOG_VERBOSITY);
        sd1.append("复位原因 %s\n", printResetReason(reset_reason));
#ifdef HAS_RTC
        if (have_rtc) {
            sd1.append("RTC时间 %d-%02d-%02d %02d:%02d:%02d\n", time_info.tm_year + 1900, time_info.tm_mon + 1,
                       time_info.tm_mday, time_info.tm_hour, time_info.tm_min, time_info.tm_sec);
        }
#endif
    }

    // Process core dump.
    readCoreDump();

    if (u8g2) {
        oled.setDisplay(u8g2);
        oled.setFlash(&flash);
        u8g2->setFont(FONT_12_GB2312);
        u8g2->setCursor(0, 52);
        u8g2->println("正在初始化...");
        oled.showInitComp();
    }

    // initialize wireless network.
    Serial.printf("Connecting to %s ", WIFI_SSID);
    connectWiFi(WIFI_SSID, WIFI_PASSWORD, 1); // usually max_tries = 25.
    if (isConnected()) {
        setupTelnet(); // todo: find another library / modify the code to support multiple client connection.
    } else {
        Serial.println("Error connecting to WiFi, Telnet startup skipped.");
    }

    // Initialize SX1276
    dualPrint("[SX1276] Initializing ... ");
    int state = initPager();
    if (state == RADIOLIB_ERR_NONE) {
        Serial.println(F("success."));
        Serial.printf("[SX1276] Actual Frequency %f MHz, ppm %.1f\n", actualFreq(ppm), ppm);
    } else {
        Serial.print(F("failed, code "));
        Serial.println(state);
        while (true);
    }

//    if(WiFi.getSleep())
//        Serial.println("WIFI Sleep enabled.");

    // start thread watchdog
    esp_task_wdt_init(WDT_TIMEOUT, true);
    esp_task_wdt_add(nullptr);
    // wdt_timer = millis64();

    digitalWrite(BOARD_LED, LED_OFF);
    Serial.printf("Booting time %llu ms ", millis64() - runtime_timer);
    sd1.append("启动用时 %llu ms\n", millis64() - runtime_timer);
    oled.drawColorUTF8f(0, 45, 0, "%1.3fV Boot %llums\n", battery.readVoltage() * 2, millis64() - runtime_timer);
    runtime_timer = 0;

    oled.updateInfo();

    Serial.printf("Mem left: %d Bytes\n", esp_get_free_heap_size());

    // test stuff
    // LBJTEST();
    // auto *test = new uint8_t[32];
    // Serial.printf("[D] test addr %p\n",test);
    // delete[] test;
    // Serial.printf("[D] test addr %p\n",test);
    // test = nullptr;
    // Serial.printf("[D] test addr %p\n",test);
    // delete[] test;
    // delete[] test;
//     Serial.printf("CPU FREQ %d MHz\n",ets_get_cpu_frequency());

}

// Loop functions
void handleTelnetCall() {
    if (give_tel_rssi) {
        telnet.printf("> RSSI %3.2f dBm.\n", radio.getRSSI(false, true));
        give_tel_rssi = false;
        telnet.print("< ");
    }
    if (give_tel_gain) {
        telnet.printf("> Gain Pos %d \n", radio.getGain());
        give_tel_gain = false;
        telnet.print("< ");
    }
    if (tel_set_ppm) {
        int16_t state = radio.setFrequency(actualFreq(ppm));
        if (state == RADIOLIB_ERR_NONE) {
            telnet.printf("> Actual Frequency %f MHz\n", actualFreq(ppm));
            Serial.printf("[Telnet] > Actual Frequency %f MHz\n", actualFreq(ppm));
        } else {
            telnet.printf("> Failure, Code %d\n", state);
            Serial.printf("[Telnet] > Failure, Code %d\n", state);
        }
        telnet.printf("> ppm set to %.f\n", ppm);
        tel_set_ppm = false;
        telnet.print("< ");
    }
}

void handleSync() {
    if (pager.gotSyncState()) {
        // if (!bandwidth_altered) {
        //     int16_t state = radio.swapRxBandwidth(12.5);
        //     Serial.printf("[D] Channelize, code %d\n",state);
        //     radio.restartReceive(true);
        //     bandwidth_altered = true;
        // }
//        sd1.append("[PGR][DEBUG] SYNC DETECTED.\n");
        if (rxInfo.cnt < 5 && (rxInfo.timer == 0 || esp_timer_get_time() - rxInfo.timer < 11000)) {
            float rssi = radio.getRSSI(false, true);
            rxInfo.timer = esp_timer_get_time();
            // rxInfo.rssi += rssi;
            rssi_cache += rssi;
            rxInfo.cnt++;
            if (rxInfo.cnt == 5) {
                Serial.printf("[D] RXI %.1f ", rssi_cache / (float) rxInfo.cnt);
            }
        }
        if (rxInfo.fer == 0)
            rxInfo.fer = radio.getFrequencyError();
    }
}


void handleTelnet() {
    if (isConnected() && !telnet_online) {
        setupTelnet();
    }
    telnet.loop();
}

void checkNetwork() {
    if (isConnected() && net_timer != 0)
        net_timer = 0;
    else if (!isConnected() && net_timer == 0)
        net_timer = millis64();

    if (!isConnected() && millis64() - net_timer > NETWORK_TIMEOUT && !no_wifi) { // 暂定解决方案：超30分钟断wifi
        telnet.stop();
        telnet_online = false;
        WiFi.disconnect();
        WiFiClass::mode(WIFI_OFF);
        Serial.println("WIFI off after 30 minutes without connection.");
        no_wifi = true;
    }

    if (ip_last != WiFi.localIP()) {
        Serial.print("Local IP ");
        Serial.print(WiFi.localIP().toString());
        Serial.print("\n");
        oled.drawIP();
    }
    ip_last = WiFi.localIP();
}

// LOOP
void loop() {
    // reset watchdog
    esp_task_wdt_reset();
    // if (millis64() - wdt_timer >= WDT_RST_PERIOD) {
    //     uint64_t t = esp_timer_get_time() ;
    //     auto r = esp_task_wdt_reset();
    //     t = esp_timer_get_time() - t;
    //     wdt_timer = millis64();
    //     Serial.printf("WDT_RST %d [%llu]\n",r,t);
    // }
#ifdef HAS_AD_BUTTON
    handleButtonInput();

    if (oled.ppmChanged() && runtime_timer == 0 && !pager.gotSyncState()) {
        actual_frequency = actualFreq(ppm);
        radio.setFrequency(actual_frequency);
        freq_last = actual_frequency;
        oled.clearPPMFlag();
        Serial.printf("[D] Frequency altered to %f MHz, ppm %.2f\n", actual_frequency, getBias(actual_frequency));
    }
#endif
    // freqCorrection();
    // Handle carrier timout.
    if (car_timer != 0 && millis64() - car_timer > 700 && prb_timer == 0 && rxInfo.timer == 0) {
        car_count = 0;
        revertFrequency();
        car_fer_last = 0;
        car_timer = 0;
        Serial.printf("[D] CARRIER TIMEOUT.");
    }

    // Handle preamble timeout.
    if (prb_timer != 0 && millis64() - prb_timer > 600 && rxInfo.timer == 0) {
        prb_count = 0;
        revertFrequency();
        for (auto &i: fers) {
            i = 0;
        }
        prb_timer = 0;
        Serial.printf("[D] PREAMBLE TIMEOUT.");
        oled.showSTR("PREAMBLE");
        screen_timer = millis64();
    }

    // if task complete, de-initialize
    if (fd_state == TASK_DONE) {
        if (task_fd != nullptr) {
            // Serial.printf("[D] NULLPTR EXCE [%llu]\n", millis64() - format_task_timer);
            vTaskDelete(task_fd);
            // Serial.printf("[D] TASK DEL [%llu]\n", millis64() - format_task_timer);
            task_fd = nullptr;
        }
        // Serial.printf("[D] NULLPTR [%llu]\n", millis64() - format_task_timer);
        initFmtVars();
        // Serial.printf("[D] INIT VARS [%llu]\n", millis64() - format_task_timer);
        // digitalWrite(BOARD_LED, LED_OFF);
        // Serial.printf("[D] LED LOW [%llu]\n", millis64() - format_task_timer);
        // changeCpuFreq(240);
        // Serial.printf("[D] FREQ CHANGED [%llu]\n", millis64() - format_task_timer);
        fd_state = TASK_INIT;
        format_task_timer = 0;
    } else if (fd_state == TASK_CREATE_FAILED) { // Handle create failure.
        initFmtVars();
        // changeCpuFreq(240);
        format_task_timer = 0;
        fd_state = TASK_INIT;
    }

    if (millis64() - led_timer > LED_ON_TIME && led_timer != 0 && fd_state == TASK_INIT) {
        // analogWrite(BOARD_LED, LED_OFF);
        led_timer = 0;
        changeCpuFreq(240);
    }

    handleSerialInput();
    checkNetwork();
    handleTelnet();
    handleTelnetCall();

    getLocalTime(&time_info, 0);
    if (time_info.tm_year + 1900 > 2001 && time_info.tm_hour != last_hour) {
        Serial.printf("[hour]change %s\n", fmtime(time_info));
        if (have_sd) {
            sd1.end();
            SD_LOG::reopenSD();
            sd1.begin("/LOGTEST");
            sd1.beginCSV("/CSVTEST");
        }
        last_hour = time_info.tm_hour;
        // TODO flash写一下
        oled.drawTime();
        // oled.updateInfo();
        screen_timer = millis64();
    }

    if (millis64() > 60000 && format_task_timer == 0 &&
        !exec_init_f80) // lower down frequency 60 sec after startup and idle.
    {
        if (isConnected())
            setCpuFrequencyMhz(80);
        else {
            WiFiClass::mode(WIFI_OFF);
            setCpuFrequencyMhz(80);
            WiFiClass::mode(WIFI_MODE_STA);
            WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
        }
        exec_init_f80 = true;
    }

    // update information on screen.
    if (screen_timer == 0) {
        screen_timer = millis64();
    } else if (millis64() - screen_timer > 6000) { // Set to 3000 to reduce interference.
        oled.updateInfo();
        screen_timer = millis64();
    }
    oled.updatePage();

    // if (millis64()%5000 == 0){
    //     sd1.append("[D] 当前运行时间 %lu ms.\n",millis64());
    //     sd1.append("[D] 测试输出：\n");
    //     LBJTEST();
    // }

    // if (millis64() - format_task_timer >= 200 && format_task_timer != 0) {
    //     Serial.printf("LED LOW [%llu]\n", millis64() - format_task_timer);
    //     digitalWrite(BOARD_LED, LED_OFF);
    //     if (fd_state == TASK_DONE || fd_state == TASK_INIT) {
    //         format_task_timer = 0;
    //         // changeCpuFreq(240);
    //     }
    // }

    // handle task timeout
    // timeout & running | created
    // todo: simplify this judgement.
    if (millis64() - format_task_timer >= FD_TASK_TIMEOUT && (fd_state == TASK_RUNNING || fd_state == TASK_CREATED)
        && task_fd != nullptr && format_task_timer != 0) {
        vTaskDelete(task_fd);
        task_fd = nullptr;
        // fd_state = TASK_TERMINATED;
        dualPrintln("[Pager] FD_TASK Timeout.");
        sd1.append("[Pager] FD_TASK Timeout.\n");
        initFmtVars();
        Serial.printf("LED LOW [%llu]\n", millis64() - format_task_timer);
        // analogWrite(BOARD_LED, LED_OFF);
        format_task_timer = 0;
        led_timer = 0;
        changeCpuFreq(240);
        fd_state = TASK_INIT;
    }
    // else if (millis64() - format_task_timer >= FD_TASK_TIMEOUT && fd_state != TASK_INIT && format_task_timer != 0 &&
    //            fd_state != TASK_RUNNING_SCREEN) { // terminate task while u8g2 operation causes main loop stuck.
    //     Serial.printf("[Pager] Task state %d \n", fd_state);
    //     if (task_fd != nullptr) {
    //         vTaskDelete(task_fd);
    //         task_fd = nullptr;
    //     }
    //     dualPrintln("[Pager] FD_TASK Timeout.");
    //     sd1.append("[Pager] FD_TASK Timeout.\n");
    //     initFmtVars();
    //     Serial.printf("LED LOW [%llu]\n", millis64() - format_task_timer);
    //     digitalWrite(BOARD_LED, LED_OFF);
    //     format_task_timer = 0;
    //     led_timer = 0;
    //     changeCpuFreq(240);
    //     fd_state = TASK_INIT;
    // }

    if (millis64() - timer4 >= 60000 && timer4 != 0 && ets_get_cpu_frequency() != 80) // fCPU to 80 after 60s in idle.
//        setCpuFrequencyMhz(80);
        changeCpuFreq(80);

    oled.autoSleep();

    handleCarrier();
    handlePreamble();

    handleSync();

    if (pager.gotPreambleState() || pager.gotSyncState()) {
        // digitalWrite(BOARD_LED, LED_ON);
        analogWrite(BOARD_LED, LED_ON_ANALOG);
    } else {
        analogWrite(BOARD_LED, LED_OFF);
    }

    // the number of batches to wait for
    // 2 batches will usually be enough to fit short and medium messages
    if (pager.available() >= 2 && fd_state == TASK_INIT) { // todo add session timeout exception to prevent stuck here.
        if (pager.available() > 2) { // MODIFY ADD
            Serial.printf("[PHY-LAYER][D] AVAILABLE %d\n", pager.available());
        }
        // Serial.println("[PHY-LAYER][D] AVAILABLE > 2.");
        setCpuFrequencyMhz(240);
        memset(db, 0, sizeof(*db)); // db = new data_bond; // MODIFY
        runtime_timer = millis64();
        timer4 = millis64();
        now_time_str(rxInfo.date_time_str);
        int state = pager.readDataAll(db->poc32, 0);
//        sd1.append("[PHY-LAYER][D] AVAILABLE > 2.\n");
        rxInfo.rssi = rssi_cache / (float) rxInfo.cnt;
        rssi_cache = 0;
        rxInfo.cnt = 0;
        rxInfo.timer = 0;
        prb_timer = 0;
        car_timer = 0;
        // radio.setRxBandwidth(20.8);
        // bandwidth_altered = false;

//        Serial.printf("CPU FREQ TO %d MHz\n",ets_get_cpu_frequency());

        Serial.printf("[D]Car*%d Prb*%d", car_count, prb_count);
        if (prb_count >= 32)
            prb_count = 31;
        if (prb_count > 0)
            rxInfo.fer = fers[prb_count - 1];
        Serial.printf(" Fer/Hz:");
        for (int i = 0; i < prb_count; ++i) {
            Serial.printf("%5.0f", fers[i]);
            fers[i] = 0;
        }
        Serial.printf("\n");
        prb_count = 0;
        car_count = 0;
        car_fer_last = 0;
        rxInfo.ppm = getBias(actual_frequency);

        // Serial.println(F("[Pager] Received pager data, decoding ... "));
        sd1.append(2, "正在解码信号...\n");

        // you can read the data as an Arduino String
        // String str = {};

        if (state == RADIOLIB_ERR_NONE) {
            freq_last = actual_frequency;
//            Serial.printf("success.\n");
//            analogWrite(BOARD_LED, 255); // MODIFY
            format_task_timer = millis64();
            led_timer = millis64();
            if (!first_rx)
                first_rx = true;

            sd1.append(2, "正在格式化输出...\n");
            // formatDataTask();
            // task_fd = xTaskCreateStaticPinnedToCore(formatDataTask, "task_fd",
            //                                      FD_TASK_STACK_SIZE, nullptr,
            //                                      2, statictask_stack, &statictask_tcb, ARDUINO_RUNNING_CORE);
            // fd_state = TASK_CREATED;
            // delay(1);

            int x_ret = 0;
            for (int i = 0; i < FD_TASK_ATTEMPTS; ++i) {
                x_ret = xTaskCreatePinnedToCore(formatDataTask, "task_fd",
                                                 FD_TASK_STACK_SIZE, nullptr,
                                                 2, &task_fd, ARDUINO_RUNNING_CORE);
                if (x_ret == pdPASS) {
                    fd_state = TASK_CREATED;
                    delay(1);
                    break;
                }
                if (x_ret != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY) {
                    dualPrintf(true, "[Pager] Failed to create format task, errcode %d\n", x_ret);
                    sd1.append("[Pager] Failed to create format task, errcode %d\n", x_ret);
                    fd_state = TASK_CREATE_FAILED;
                    // analogWrite(BOARD_LED, LED_OFF);
                }
                Serial.printf("[Pager] FTask failed memory allocation, error %d, mem left %d B, retry %d\n",
                              x_ret, esp_get_free_heap_size(), i);
                sd1.append("[Pager] FTask failed memory allocation, error %d, mem left %d B, retry %d\n",
                           x_ret, esp_get_free_heap_size(), i);
            }
            if (x_ret == errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY) {
                    fd_state = TASK_CREATE_FAILED;
                    simpleFormatTask();
                    // analogWrite(BOARD_LED, LED_OFF);
                    esp_restart(); // MODIFY ADD
            }
        } else if (state == RADIOLIB_ERR_MSG_CORRUPT) {
//            Serial.printf("failed.\n");
//            Serial.println("[Pager] Reception failed, too many errors.");
            dualPrintf(true, "[Pager] Reception failed, too many errors. \n");
            revertFrequency();
//            sd1.append("[Pager] Reception failed, too many errors. \n");
            oled.showSTR("CORRUPT");
            // db->poc32.text;
        } else {
            // some error occurred
            sd1.append("[Pager] Reception failed, code %d \n", state);
            dualPrintf(true, "[Pager] Reception failed, code %d \n", state);
        }

        // if task was not called.
        if (fd_state == TASK_INIT) {
            initFmtVars();
        } else if (fd_state == TASK_CREATED && task_fd == nullptr) {
            fd_state = TASK_DONE;
        }
    }
}

#ifdef HAS_AD_BUTTON

void handleButtonInput() {
    if (analogRead(BUTTON_PIN) >= 550) { // 1300
        if (btn_timer == 0) {
            btn_timer = millis64();
        }
        if (millis64() - btn_timer <= 200 && !btn_pressed) {
            uint16_t btn_level_prev = analogRead(BUTTON_PIN);
            uint16_t btn_level = analogRead(BUTTON_PIN);
            if (btn_level >= 580 && btn_level <= 660 && abs(btn_level - btn_level_prev) < 10) {
                btn_pressed = true;
                oled.updateSleepTimestamp();
                // Serial.printf("[D] GPIO 34: %d ADU, KEY %d\n", btn_level, 1);
                if (!oled.isEnabled() || oled.isSleep())
                    return;
                // if (oled.isSleep()) {
                //     oled.setSleep(false);
                //     oled.updateInfo();
                //     return;
                // }
                if (!oled.isMenu()) {
                    if (first_rx || !always_new) {
                        always_new = false;
                    }
                    oled.openMenu();
                } else {
                    oled.closeMenu();
                    // oled.handleKey(KEY_LEFT);
                }
            } else if (btn_level >= 1350 && btn_level <= 1490 && abs(btn_level - btn_level_prev) < 10) { // 1460-1490
                btn_pressed = true;
                oled.updateSleepTimestamp();
                // Serial.printf("[D] GPIO 34: %d ADU, KEY %d\n", btn_level, 2);
                if (!oled.isEnabled() || oled.isSleep())
                    return;
                // if (oled.isSleep()) {
                //     oled.setSleep(false);
                //     oled.updateInfo();
                //     return;
                // }
                if (!oled.isMenu()) {
                    flash.toLatest();
                    oled.showSelectedLBJ(0);
                    always_new = true;
                } else {
                    oled.handleKey(KEY_RIGHT);
                }
            } else if (btn_level >= 2100 && btn_level <= 2280) { // 2250-2280
                btn_pressed = true;
                oled.updateSleepTimestamp();
                // Serial.printf("[D] GPIO 34: %d ADU, KEY %d\n", btn_level, 3);
                if (!oled.isEnabled() || oled.isSleep())
                    return;
                // if (oled.isSleep()) {
                //     oled.setSleep(false);
                //     oled.updateInfo();
                //     return;
                // }
                if (!oled.isMenu()) {
                    always_new = false;
                    oled.showSelectedLBJ(-1);
                } else {
                    oled.handleKey(KEY_UP);
                }
            } else if (btn_level >= 2900 && btn_level <= 3110) { // 2990-3110
                btn_pressed = true;
                oled.updateSleepTimestamp();
                // Serial.printf("[D] GPIO 34: %d ADU, KEY %d\n", btn_level, 4);
                if (!oled.isEnabled() || oled.isSleep())
                    return;
                // if (oled.isSleep()) {
                //     oled.setSleep(false);
                //     oled.updateInfo();
                //     return;
                // }
                if (!oled.isMenu()) {
                    always_new = false;
                    oled.showSelectedLBJ(1);
                } else {
                    oled.handleKey(KEY_DOWN);
                }
            } else if (btn_level >= 4090 && btn_level <= 4096) {
                btn_pressed = true;
                oled.updateSleepTimestamp();
                // Serial.printf("[D] GPIO 34: %d ADU, KEY %d\n", btn_level, 5);
                if (!oled.isEnabled()) {
                    oled.setEnable(true);
                    oled.resumeUpdate();
                    oled.updateInfo();
                }
                if (oled.isSleep()) {
                    oled.setSleep(false);
                    oled.updateInfo();
                    // oled.resumeUpdate();
                    return;
                }
                if (!oled.isMenu()) {
                    if (first_rx) {
                        flash.toLatest();
                        oled.showSelectedLBJ(0);
                    } else {
                        flash.toLatest();
                        oled.showSelectedLBJ(0);
                        // oled.showListening();
                        // flash.toLatest(0);
                    }
                    always_new = true;
                    oled.resumeUpdate();
                } else {
                    oled.acknowledge();
                }
            } else {
                // Serial.printf("[D] GPIO 34: %d ADU", btn_level);
                // Serial.println(", KEY ?");
            }
            // delay(100);
        } else if (millis64() - btn_timer > 200) {
            btn_timer = 0;
            btn_pressed = false;
        }

    } else if (btn_timer != 0) {
        btn_timer = 0;
        btn_pressed = false;
    }
}

#endif

void revertFrequency() {
    if (actual_frequency != freq_last) {
        actual_frequency = freq_last;
        int state = radio.setFrequency(actual_frequency);
        if (state != RADIOLIB_ERR_NONE) {
            Serial.printf("[D] Revert freq failed %d\n", state);
        } else {
            Serial.printf("[D] Revert to last freq %f MHz, ppm %.2f\n", actual_frequency, getBias(actual_frequency));
        }
    }
}

void handleCarrier() {
    if (pager.gotCarrierState() && !pager.gotPreambleState() && !pager.gotSyncState() && freq_correction &&
        prb_timer == 0) {
        if (car_count == 0)
            car_timer = millis64();
        ++car_count;
        if (car_count < 64) {
            float fei = radio.getFrequencyError();
            // Serial.printf("[D] Carrier FEI %.2f Hz, count %d\n",fei,car_count);
            if (abs(fei) > 1000.0 && car_count != 1 &&
                abs(fei - car_fer_last) < 500) {
                // Perform frequency correction
                auto target_freq = (float) (actual_frequency + fei * 1e-6);
                int state = radio.setFrequency(target_freq);
                if (state != RADIOLIB_ERR_NONE) {
                    Serial.printf("[D][C] Freq Alter failed %d, target freq %f\n", state, target_freq);
                    sd1.append("[D][C] Freq Alter failed %d, target freq %f\n", state, target_freq);
                } else {
                    actual_frequency = target_freq;
                    Serial.printf("[D][C] Freq Altered %f MHz, FEI %.2f Hz, PPM %.2f\n", actual_frequency, fei,
                                  getBias(actual_frequency));
                    oled.drawPPM(getBias(actual_frequency));
                }
            }
            car_fer_last = fei;
        }
    }
}

void handlePreamble() {
    if (pager.gotPreambleState() && !pager.gotSyncState() && freq_correction) {
        if (prb_count == 0)
            prb_timer = millis64();
        // if (millis64() - prb_timer > 500) {
        //     prb_count = 0;
        //     if (actual_frequency != freq_last) {
        //         actual_frequency = freq_last;
        //         int state = radio.setFrequency(actual_frequency);
        //         if (state != RADIOLIB_ERR_NONE) {
        //             Serial.printf("[D] Freq Alter failed %d\n", state);
        //         }
        //     }
        //     for (auto &i: fers) {
        //         i = 0;
        //     }
        // }
        ++prb_count;
        if (prb_count < 32) {
            // todo: Implement automatic bandwidth adjustment.
            // if (prb_count > 2 && !bandwidth_altered) {
            //     int16_t state = radio.swapRxBandwidth(12.5);
            //     Serial.printf("[D] Bandwidth to 12.5,code %d\n",state);
            //     radio.restartReceive(true);
            //     bandwidth_altered = true;
            // }
            // else if (prb_count > 6 && bandwidth_altered) {
            //     radio.swapRxBandwidth(12.5);
            //     bandwidth_altered = false;
            // }
            // radio.swapRxBandwidth(12.5);
            fers[prb_count - 1] = radio.getFrequencyError();
            if (abs(fers[prb_count - 1]) > 1000.0 && prb_count != 1 &&
                abs(fers[prb_count - 1] - fers[prb_count - 2]) < 500) {
                // Perform frequency correction
                auto target_freq = (float) (actual_frequency + fers[prb_count - 1] * 1e-6);
                int state = radio.setFrequency(target_freq);
                if (state != RADIOLIB_ERR_NONE) {
                    Serial.printf("[D][P] Freq Alter failed %d, target freq %f\n", state, target_freq);
                    sd1.append("[D][P] Freq Alter failed %d, target freq %f\n", state, target_freq);
                } else {
                    actual_frequency = target_freq;
                    Serial.printf("[D][P] Freq Altered %f MHz, FEI %.2f Hz, PPM %.2f\n", actual_frequency,
                                  fers[prb_count - 1], getBias(actual_frequency));
                    oled.drawPPM(getBias(actual_frequency));
                }
            }
        }
    }
}

void getCoreFreq(void *pVoid) {
    Serial.printf("Core %d Frequency %d MHz\n", xPortGetCoreID(), ets_get_cpu_frequency());
    vTaskDelete(nullptr);
}

void handleSerialInput() {
    if (Serial.available()) {
        String in = Serial.readStringUntil('\r');
        if (in == "ping")
            Serial.println("$ Pong");
        else if (in == "task state")
            Serial.println("$ Task state " + String(fd_state));
        else if (in == "rtc") {
#ifdef HAS_RTC
            if (have_rtc) {
                // rtc.getDateTime(time_info);
                // DateTime now = rtc.now();
                time_info = rtcLibtoC(rtc.now());
                float temp = rtc.getTemperature();
                Serial.print(&time_info, "$ [eRTC] %Y-%m-%d %H:%M:%S ");
                Serial.printf("Temp: %.2f °C\n", temp);
            }
#endif
        } else if (in == "time" || in == "t") {
            getLocalTime(&time_info, 1);
            Serial.printf("$ SYS Time %s, %d Up time %llu.%03llus\nreset reason:%s\n", 
                fmtime(time_info), 
                start_cnt, millis64()/1000, millis64()%1000,
                printResetReason(esp_reset_reason())
            );
        } else if (in == "cd") {
            if (have_cd)
                Serial.println("$ Core dump exported.");
            else
                Serial.println("$ No core dump.");
        } else if (in == "sd end") {
            if (!sd1.status())
                Serial.println("$ [SDLOG] No SD.");
            else {
                sd1.append("[SDLOG] SD卡将被卸载\n");
                sd1.end();
                Serial.println("$ [SDLOG] SD end.");
            }
        } else if (in == "sd begin") {
            if (sd1.status())
                Serial.println("$ End SD First.");
            else {
                SD_LOG::reopenSD();
                sd1.begin("/LOGTEST");
                sd1.beginCSV("/CSVTEST");
                sd1.append("[SDLOG] SD卡已重新挂载\n");
                Serial.println("$ [SDLOG] SD reopen.");
            }
        } else if (in == "mem") {
            Serial.printf("$ Mem left: %d Bytes\n", esp_get_free_heap_size());
        } else if (in == "rst") {
            Serial.printf("$ RST: %s\n", printResetReason(esp_reset_reason()));
        } else if (in == "ppm") {
            if (runtime_timer == 0 && !pager.gotSyncState()) {
                ppm = 3;
                int16_t state = radio.setFrequency(actualFreq(ppm));
                if (state == RADIOLIB_ERR_NONE)
                    Serial.printf("$ Actual Frequency %f MHz\n", actualFreq(ppm));
                else
                    Serial.printf("$ Failure, Code %d\n", state);
            } else {
                Serial.println("$ Unable to change frequency due to occupation");
                if (pager.available())
                    Serial.println("$ pager.available == true");
                if (runtime_timer)
                    Serial.printf("$ runtime_timer = %llu, running %llu\n", runtime_timer, millis64() - runtime_timer);
            }
        } else if (in == "ppm read") {
            Serial.printf("$ ppm %.1f\n", ppm);
        } else if (in == "afc off") {
            prb_count = 0;
            prb_timer = 0;
            car_count = 0;
            car_timer = 0;
            freq_correction = false;
            Serial.println("$ Frequency Correction Disabled");
        } else if (in == "afc on") {
            freq_correction = true;
            Serial.println("$ Frequency Correction Enabled");
        } else if (in == "rssi") {
            Serial.printf("$ RSSI %3.2f dBm.\n", radio.getRSSI(false, true));
        } else if (in == "gain") {
            Serial.printf("$ RegLna(0x0C) = 0x%x/",radio.getGain());
            Serial.println(radio.getGain(), BIN);
        } else if (in == "reg") {
            RadioReg();
        } else if (in == "cpu") {
            xTaskCreatePinnedToCore(getCoreFreq, "get_freq", 2048, nullptr,
                                    1, nullptr, 0);
            Serial.printf("Core %d Frequency %d MHz\n", xPortGetCoreID(), ets_get_cpu_frequency());
        }
            // else if (in == "flash read") {
            //     flash.readFile("/CACHE");
            // }
        else if (in == "flash clear") {
            flash.clearKeys();
        } else if (in == "flash re") {
            // String str;
            // flash.retrieveLine(172,&str);
            // Serial.println(str);
            PagerClient::poc32 poc32;
            lbj_data lbj;
            rx_info rx;
            uint32_t id;
            flash.retrieve(&poc32, &lbj, &rx, &id, 0);
            oled.showLBJ(poc32, lbj, rx);
        } else if (in == "flash stat") {
            flash.getStats();
        }
    }
}

void initFmtVars() {
    Serial.printf("[Pager][%llu ms].\n", millis64() - runtime_timer);
    runtime_timer = 0;
    rxInfo.rssi = 0;
    rxInfo.fer = 0;
    rxInfo.ppm = 0;
    // prb_count = 0;
    // for (auto &i: fers) {
    //     i = 0;
    // }
    // if (db != nullptr) {
    //     delete db;
    //     db = nullptr;
    // }
    memset(db, 0, sizeof(*db));
}

void formatDataTask(void *pVoid) {
    fd_state = TASK_RUNNING;
    // Serial.printf("[FD-Task] Stack High Mark Begin %u\n", uxTaskGetStackHighWaterMark(nullptr));
    sd1.append(2, "格式化任务已创建\n");
    if (db->poc32.word_idx == 0) {
        fd_state = TASK_DONE;
        task_fd = nullptr;
        vTaskDelete(nullptr);
        Serial.println("[D] Empty message");
    }

    float temp = 0.01;
#ifdef HAS_RTC
    if (have_rtc)
        temp = rtc.getTemperature();
#endif

    // Serial.printf("[FD-Task] Stack High Mark pDATA %u\n", uxTaskGetStackHighWaterMark(nullptr));
    // sd1.append(2, "原始数据输出完成，用时[%llu]\n", millis64() - runtime_timer);
    // Serial.printf("decode[%llu]", millis64() - runtime_timer); // MODIFY
    readDataLBJ(db->poc32, &db->lbjData);
    sd1.append(2, "LBJ读取完成，用时[%llu]\n", millis64() - runtime_timer);
    // Serial.printf("Read[%llu]", millis64() - runtime_timer); // MODIFY
    // Serial.printf("[FD-Task] Stack High Mark rLBJ %u\n", uxTaskGetStackHighWaterMark(nullptr));
    // Serial.printf("[D-LEPI][%s]", db->lbjData.epi.c_str());

#ifdef HAS_DISPLAY
    fd_state = TASK_RUNNING_SCREEN;
    if (u8g2) {
        oled.updateSleepTimestamp();
        if (oled.isSleep()) {
            oled.setSleep(false);
            oled.updateInfo();
        }
        oled.showLBJ(db->poc32, db->lbjData, rxInfo);
        screen_timer = millis64(); // MODIFY ADD
        // Serial.printf("u8g2[%llu]", millis64() - runtime_timer);
    } else {
        Serial.printf("u8g2null[%d]", u8g2 != nullptr);
    }
#endif

    uint64_t u8g2time = millis64() - runtime_timer;
    printDataSerial(db->poc32, db->lbjData, rxInfo);
    sd1.append(2, "串口输出完成，用时[%llu]\n", millis64() - runtime_timer);
    Serial.printf("u8g2[%llu]", u8g2time);
    Serial.printf("TX[%llu]", millis64() - runtime_timer);

    printDataTelnet(db->poc32, db->lbjData, rxInfo);
    Serial.printf("telnet[%llu]", millis64() - runtime_timer);

    flash.append(db->poc32, db->lbjData, rxInfo);
    if (always_new)
        flash.toLatest();
    Serial.printf("flash[%llu]", millis64() - runtime_timer);

    // sd1.disableSizeCheck();
    appendDataCSV(db->poc32, db->lbjData, rxInfo);
    Serial.printf("csv[%llu]", millis64() - runtime_timer);
    // appendDataLog(db->poc32, db->lbjData, rxInfo);
    // Serial.printf("sd[%llu]", millis64() - runtime_timer);
    // sd1.enableSizeCheck();

    Serial.printf("[FD-Task] Stack High Mark %u", uxTaskGetStackHighWaterMark(nullptr));
    sd1.append(2, "任务堆栈标 %u\n", uxTaskGetStackHighWaterMark(nullptr));
    // sd1.append("[FD-Task] Stack High Mark %u\n", uxTaskGetStackHighWaterMark(nullptr));
    sd1.append(2, "格式化输出任务完成，用时[%llu]\n", millis64() - runtime_timer);
    fd_state = TASK_DONE;
    task_fd = nullptr;
    vTaskDelete(nullptr);
}

void simpleFormatTask() { // only output initially phrased data in case of memory shortage
    sd1.append("[PGR]%s\n", db->poc32.text);
    // pword(db->str.c_str(),20,50);
    readDataLBJ(db->poc32, &db->lbjData);
    appendDataCSV(db->poc32, db->lbjData, rxInfo);
    oled.showSTR(db->poc32.text+5);
}
// END OF FILE.